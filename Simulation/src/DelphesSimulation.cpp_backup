#include "DelphesSimulation.h"
// for Delphes

// ROOT
#include "TLorentzVector.h"
#include "TBranch.h"
#include "TFile.h"
#include "TTree.h"


#include "TApplication.h"

#include "TObjArray.h"
#include "TStopwatch.h"
#include "TDatabasePDG.h"
#include "TParticlePDG.h"
#include "Math/GenVector/LorentzVector.h"

#include "classes/DelphesModule.h"

//#include "SortableObject.h"
#include "classes/DelphesClasses.h"
#include "modules/Delphes.h"


#include "classes/DelphesFactory.h"
#include "classes/DelphesHepMCReader.h"
#include "ExRootAnalysis/ExRootConfReader.h"
//#include "ExRootAnalysis/ExRootTreeWriter.h"

#include "ExRootAnalysis/ExRootTask.h"
#include "ExRootAnalysis/ExRootTreeBranch.h"
#include "ExRootAnalysis/ExRootProgressBar.h"


// STL
#include <iostream>
#include <vector>

#include <stdexcept>
#include <sstream>

#include <signal.h>

static bool interrupted = false;
using namespace std;


DECLARE_COMPONENT(DelphesSimulation)

DelphesSimulation::DelphesSimulation(const std::string& name, ISvcLocator* svcLoc):
GaudiAlgorithm(name, svcLoc) ,
  m_filename(),
  m_detectorcard()
 {
  //  declareInput("detectorCard", detectorCard_);
  declareProperty("filename", m_filename="" , "Name of the HepMC file to read");
  declareProperty("detectorcard", m_detectorcard="" , "Name of the tcl file with detector and simulation configuration");

  //  declareInput("filename", m_filename);
  //declareOutput("detectorcard", m_detectorcard);
  declareOutput("particles", m_recphandle);
  declareOutput("muons", m_recmhandle);

}

StatusCode DelphesSimulation::initialize() {
  return StatusCode::SUCCESS;
}

StatusCode DelphesSimulation::execute() {
  // const MCParticleCollection* inparticles = m_genphandle.get();

 // delphes stuff here
  // delphes stuff here
  //  ExRootTreeWriter *treeWriter = 0; // it will always remain to 0 ??? ....
  //  ExRootTreeBranch *branchEvent = 0;
  ExRootConfReader *confReader = 0;
  Delphes *modularDelphes = 0;
  DelphesFactory *factory = 0;


  TObjArray *stableParticleOutputArray = 0, *allParticleOutputArray = 0, *partonOutputArray = 0, *muonOutputArray =0;
  DelphesHepMCReader *reader = 0;
  Int_t i, maxEvents, skipEvents;
  Long64_t length, eventCounter;
  FILE *inputFile = 0;
  // FILE *detectorFile = 0;
  TFile *outputFile = 0; 
  stringstream message;
  TStopwatch readStopWatch, procStopWatch;
  
  
  
  // the input files is an HEPMC file
  cout << "** Reading " << m_filename << endl;
  inputFile = fopen(m_filename.c_str(), "r");
  
  if(inputFile == NULL)
    {
      message << "can't open " << m_filename;
      throw runtime_error(message.str());
    }
  
  fseek(inputFile, 0L, SEEK_END);     
  
  length = ftello(inputFile);
  fseek(inputFile, 0L, SEEK_SET);
  

  
  cout << "** length of input file " << length << endl;
  
  if(length <= 0)
    {
      fclose(inputFile);
    }
  
  
  // now read delphes card
  
  confReader = new ExRootConfReader;
  //  detectorFile = fopen(m_detectorcard.c_str(), "r");
  confReader->ReadFile(m_detectorcard.c_str());
  
  maxEvents = confReader->GetInt("::MaxEvents", 0);
  skipEvents = confReader->GetInt("::SkipEvents", 0);
  
  if(maxEvents < 0)
    {
      throw runtime_error("MaxEvents must be zero or positive");
    }
  
  if(skipEvents < 0)
    {
      throw runtime_error("SkipEvents must be zero or positive");
    }
  
  
  
  modularDelphes = new Delphes("Delphes");
  modularDelphes->SetConfReader(confReader);
  //  modularDelphes->SetTreeWriter(treeWriter);
  
  

  factory = modularDelphes->GetFactory();
  allParticleOutputArray = modularDelphes->ExportArray("allParticles");
  stableParticleOutputArray = modularDelphes->ExportArray("stableParticles");
  partonOutputArray = modularDelphes->ExportArray("partons");
  muonOutputArray = modularDelphes->ExportArray("muons");
  
  
  reader = new DelphesHepMCReader;
 // now access delphes recontructed particles
  reader->SetInputFile(inputFile);
 
 
  modularDelphes->InitTask();
  


  
 
  
  ExRootProgressBar progressBar(length);
  

  // Loop over all objects                                                                              
  eventCounter = 0;
  modularDelphes->Clear();
  reader->Clear();
  readStopWatch.Start();
  
  
  ParticleCollection* particles = new ParticleCollection();
  ParticleCollection* muons = new ParticleCollection();

  //   EventInfoCollection& evinfocoll = store.create<EventInfoCollection>("EventInfo");
  // ParticleCollection& pcoll = store.create<ParticleCollection>("Particle");
  
  //  writer.registerForWrite<EventInfoCollection>("EventInfo");
  
  // collections from the dummy generator
  // writer.registerForWrite<ParticleCollection>("Particle");

  
 


  while((maxEvents <= 0 || eventCounter - skipEvents < maxEvents) &&
        reader->ReadBlock(factory, allParticleOutputArray,
			  stableParticleOutputArray, partonOutputArray, muonOutputArray ) && !interrupted)
    {
      if(reader->EventReady())
        {
          ++eventCounter;
	  
          readStopWatch.Stop();
	  
          if(eventCounter > skipEvents)
	    {
	      procStopWatch.Start();
	      modularDelphes->ProcessTask();
	      procStopWatch.Stop();
	      
	      // fill event information
	      
	      // EventInfoCollection* evinfocoll = nullptr;
	      
	      //store.get("EventInfo", evinfocoll);
	      //if(evinfocoll==nullptr) {
	      //		std::cerr<<"collection EventInfo does not exist!"<<std::endl;
	      //return 1;
	      // }
	      //EventInfoHandle evinfo = evinfocoll->create();
	      //evinfo.mod().Number = eventCounter;

	      
	      Candidate * candidate;
	      for(i = 0; i < stableParticleOutputArray->GetEntriesFast(); ++i)
		{
		  candidate = static_cast<Candidate *>(stableParticleOutputArray->At(i));
		  /* std::cout << "reading a candidate " << std::endl;
		     std::cout << "cand PID " << candidate->PID << std::endl;
		     std::cout << "cand Status " << candidate->Status << std::endl;
		  */
		  // here, asking the store for the collection.
		  // could also just reuse the reference obtained at the time of the creation
		  // of the collection
		  
		  ParticleHandle& outptc = particles->create();		  
                  BareParticle& core = outptc.mod().Core;
		  core.Type = candidate->PID; 
		  core.Status = candidate->Status;
		  core.P4.Pt = (double  ) candidate->Momentum.Pt();
		  core.P4.Eta = (double ) candidate->Momentum.Eta();
		  core.P4.Phi = (double ) candidate->Momentum.Phi();
		  core.P4.Mass = (double ) candidate->Mass ;
		  
	  
		  //		  if(eventCounter%1000 == 0) {
		  // std::cout<<"writing a stable particle with pT="<<core.P4.Pt<<std::endl;  
		    
		  //}

      
      
	      
		}

	      Candidate * mucandidate;
	      for(i = 0; i < muonOutputArray->GetEntriesFast(); ++i)
		{
		  mucandidate = static_cast<Candidate *>(muonOutputArray->At(i));
		  /* std::cout << "reading a candidate " << std::endl;
		     std::cout << "cand PID " << candidate->PID << std::endl;
		     std::cout << "cand Status " << candidate->Status << std::endl;
		  */
		  // here, asking the store for the collection.
		  // could also just reuse the reference obtained at the time of the creation
		  // of the collection
		  
		  ParticleHandle& outptc = muons->create();		  
                  BareParticle& core = outptc.mod().Core;
		  core.Type = mucandidate->PID; 
		  core.Status = mucandidate->Status;
		  core.P4.Pt = (double  ) mucandidate->Momentum.Pt();
		  core.P4.Eta = (double ) mucandidate->Momentum.Eta();
		  core.P4.Phi = (double ) mucandidate->Momentum.Phi();
		  core.P4.Mass = (double ) mucandidate->Mass ;
		  
	  
		  //		  if(eventCounter%1000 == 0) {
		  // std::cout<<"writing a stable particle with pT="<<core.P4.Pt<<std::endl;  
		    
		  //}

      
      
	      
		}


	      	   
	    }

	
	  
	  //	      writer.writeEvent();
	  //    store.next();
	  
	
	  
      modularDelphes->Clear();
      reader->Clear();
      
      readStopWatch.Start();
	}
      progressBar.Update(ftello(inputFile), eventCounter);
    }
  
  
  
  
  fseek(inputFile, 0L, SEEK_END);
  progressBar.Update(ftello(inputFile), eventCounter, kTRUE);
  progressBar.Finish();
  
  if(inputFile != stdin) fclose(inputFile);
      


  
  
  modularDelphes->FinishTask();
  
  
  
  cout << "** Exiting..." << endl;

   m_recphandle.put(particles);
   m_recphandle.put(muons);

  //  writer.finish();
  
  delete reader;
  delete modularDelphes;
  delete confReader;
  delete outputFile;

  return StatusCode::SUCCESS;
}

StatusCode DelphesSimulation::finalize() {
  return GaudiAlgorithm::finalize();
}
